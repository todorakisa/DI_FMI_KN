1. Стек

Характеристики спрямо реализацията
. статична
- реализация чрез статичен масив
- променлива за големина на стека size
- фиксирана макс. размер на стека
- create(n) <==> size = 0; arr = new T[n]; , О(n) сложност по памет 
- empty() <==> size == 0, О(1) сложност по време и памет
- push(x) <==> arr[size] = x; size++; , О(1) сложност по време и памет
- pop() <==> size--; , О(1) сложност по време и памет
- peek() <==> return arr[size - 1]; , О(1) сложност по време и памет
- крайно проста, негъвкава реализация

. динамична
- реализация чрез динамичен масив
- променлива за големина на стека size
- променлива за големина на масива arr_size
- динамичен размер на стека
- create() <==> size = 0; arr = new T[const]; , О(1) сложност по време и памет 
- empty() <==> size == 0, О(1) сложност по време и памет
- push(x) <==> 
	.. ако size < arr_size, тогава arr[size] = x; size++; , О(1) сложност по време и памет
	.. иначе създаваме нов масив с двойна на предния големина, "прехвърляме" елементите в новия и освобождаваме паметта за стария. След това същото като горе, О(n) сложност по време и памет
- pop() <==> size--; , О(1) сложност по време и памет
- peek() <==> return arr[size - 1]; , О(1) сложност по време и памет
- по-добра реализация от предната, но не достатъчно

. свързана
- реализация чрез структура Node
- динамичен размер на стека
- променлива top за връх на стека
- create() <==> top = null; , О(1) сложност по време и памет 
- empty() <==> top == null, О(1) сложност по време и памет
- push(x) <==> Node* temp = new Node(x); temp->next = top; top = temp; , О(1) сложност по време и памет
- pop() <==> Node* temp = top; top = top->next; delete temp; , О(1) сложност по време и памет
- peek() <==> return top->data; , О(1) сложност по време и памет
- най-добра от 3те реализации

РЕАЛИЗАЦИЯ (свързана):


2. Опашка

Характеристики спрямо реализацията
. статична
- реализация чрез статичен масив
- променлива за край на опашката back
- променлива за начало на опашката front
- фиксирана макс. размер на опашката
- create(n) <==> front = 0, back = 0; arr = new T[n]; , О(n) сложност по памет 
- empty() <==> front == back, О(1) сложност по време и памет
- enqueue(x) <==>
		..ако няма място в масива, грешка
		..ако сме стигнали края на масива, пробваме да добавим в началото му (back=0, back++)
		..иначе arr[back] = x; back++; 
O(1) сложност по време и памет
- dequeue() <==> front++; (ако front е стигнал края на масива, то front=0;) , О(1) сложност по време и памет
- head() <==> return arr[front - 1]; , О(1) сложност по време и памет
- крайно проста, негъвкава реализация

. динамична
- променлива за край на опашката back
- променлива за начало на опашката front
- динамичен макс. размер на опашката
- create(n) <==> front = 0, back = 0; arr = new T[n]; , О(n) сложност по памет 
- empty() <==> front == back, О(1) сложност по време и памет
- enqueue(x) <==> 
		..ако няма място в масива, заделяме нов масив с двоен размер, "прехвърляме" елементите от стария в новия масив и освобождаваме паметта на стария
		..ако сме стигнали края на масива, пробваме да добавим в началото му (back=0, back++)
		..иначе arr[back] = x; back++; 
O(n) сложност по време и памет в най-лошия случай
- dequeue() <==> front++; (ако front е стигнал края на масива, то front=0;) , О(1) сложност по време и памет
- head() <==> return arr[front - 1]; , О(1) сложност по време и памет
- по-добра реализация от предната, но не достатъчно

. свързана
- реализация чрез структура Node
- динамичен размер на опашката
- променлива за край на опашката back
- променлива за начало на опашката front
- create() <==> front = back = null; , О(1) сложност по време и памет 
- empty() <==> front == null, О(1) сложност по време и памет
- enqueue(x) <==> Node* temp = new Node(x); back->next = temp; back = temp; , О(1) сложност по време и памет
- dequeue() <==> Node* temp = front; top = top->next; delete temp; , О(1) сложност по време и памет
- head() <==> return front->data; , О(1) сложност по време и памет
- най-добра от 3те реализации

РЕАЛИЗАЦИЯ (свързана):



3. Списък

Характеристики спрямо реализацията
. с една връзка
общо взето като при свързаното представяне при опашката
- create() <==> front = back = null; О(1) сложност по време и памет
- empty()  <==> front == null; О(1) сложност по време и памет
- insert(x, p) <==> итерираме с temp указател p-1 пъти, after = temp->next; temp->next = newElem; newElem->next = after; О(n) сложност по време
- delete(p) <==> итерираме с temp указател p-1 пъти, toDelete = temp; предния елемент се насочва към temp->next; delete toDelete; О(n) сложност по време
- get(p) <==> итерираме с temp указател p-1 пъти, return temp->data; О(n) сложност по време


. с две връзки
тук Node структурата има две връзки: prev и next 	
Операциите са същите като горе. Предимството е, ако ползваме итератор. Тогава можем да добавяме и премахваме за константно време преди и след текущия елемент 
(с една връзка можем само след, а преди ще е с линейно време).

4. Дървета

(Дървета без фискиран брой на децата)
Начини на представяне в паметта:
. свързано
Свързана структура от възли, където всеки възел се състои от:
- стойността в корена
- списък от възли, представящи поддърветата (децата)

. последователно
Последователност от тройки: корен най-ляво дете, десен брат

(Дървета с фискиран брой на децата)
. свързано
Свързана структура от тройни кутии:
- стойността в корена
- ляво дете
- дясно дете

. последователно
Последователност от тройки: корен, ляво, дясно


5. Двоично дърво за търсене
да разгелдам имплементацията от на Нора github-а

